<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono|VT323" rel="stylesheet"> 
    <link href="css/build/style.css" rel="stylesheet"> 
    <title>Multimedia homework</title>
</head>
<body>
    <div class="wrapper">
        <video class="video" loop="loop" width="400px"></video>
            <!--poster="https://source.unsplash.com/random/600x400"-->
        <div class="interface">
            <p class="glitch">Hello everyone</p>
        </div>
        <!-- <div class="motion"></div> -->
        <canvas class="canvas"></canvas>
    </div>
</body>
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/641/web-animations-next.min.js"></script>
<script>

window.AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();

const constraints = {
    video: true,
    audio: true
};

const video = document.querySelector('.video');

function drawBuffer( width, height, context, data ) {
    var step = Math.ceil( data.length / width );
    var amp = height / 2;
    context.fillStyle = "silver";
    context.clearRect(0,0,width,height);
    for(var i=0; i < width; i++){
        var min = 1.0;
        var max = -1.0;
        for (j=0; j<step; j++) {
            var datum = data[(i*step)+j]; 
            if (datum < min)
                min = datum;
            if (datum > max)
                max = datum;
        }
        context.fillRect(i,(1+min)*amp,1,Math.max(1,(max-min)*amp));
    }
}


function handleSuccess(stream) {
    console.log(stream)
    video.srcObject = stream;
    const audioInput = audioContext.createMediaStreamSource(stream);
    const inputNode = audioContext.createGain();
    inputNode.gain.value = 2;
    audioInput.connect(inputNode);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    inputNode.connect(analyser);
    // analyser.connect(audioContext.destination);
    const dataArray = new Uint8Array(analyser.fftSize); // Uint8Array should be the same length as the fftSize 
    // drawBuffer(200, 100, document.querySelector('.canvas').getContext('2d'), dataArray);
    const myCanvas = document.querySelector('.canvas').getContext('2d')
    WIDTH = 800;
    HEIGHT = 150;
    bufferLength = 2048;
    myCanvas.clearRect(0, 0, WIDTH, HEIGHT);

    function draw() {
        drawVisual = requestAnimationFrame(draw);
        analyser.getByteTimeDomainData(dataArray);
        
        myCanvas.fillRect(0, 0, WIDTH, HEIGHT);
        myCanvas.lineWidth = 4;
        myCanvas.strokeStyle = 'lightgreen';

        myCanvas.beginPath();
        var sliceWidth = WIDTH * 1.0 / bufferLength;
        var x = 0;
        
        for(var i = 0; i < bufferLength; i++) {
    
            var v = dataArray[i] / 128.0;
            var y = (v-1)*30 + HEIGHT/2;

            if(i === 0) {
            myCanvas.moveTo(x, y);
            } else {
            myCanvas.lineTo(x, y);
            }

            x += sliceWidth;
        };
    
        myCanvas.lineTo(canvas.width, canvas.height/2);
        myCanvas.stroke();
        };

    draw();

}

function handleError(error) {
  console.error('Reeeejected!', error);
}

navigator.mediaDevices.getUserMedia(constraints).
  then(handleSuccess).catch(handleError);

function comparePixel(p1, p2) {
	var matches = true;
	var sensitivity = 40;
 
	for(var i = 0; i < p1.length; i++) {
		var t1 = Math.round(p1[i]/10)*10;
		var t2 = Math.round(p2[i]/10)*10;
 
		if(t1 != t2) {
			if((t1+sensitivity < t2 || t1-sensitivity > t2)) {
				matches = false;
			}
		}
	}
 
	return matches;
}

function saturateGreen(imageData) {
    for (var i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] = 0;
        imageData.data[i + 1] = Math.min(imageData.data[i + 1]*4, 255);
        imageData.data[i + 2] = 0;
    }
    return imageData;
}

document.addEventListener('DOMContentLoaded', function() {
    const glitch = this.querySelector('.glitch');
    glitch.dataset.text = glitch.innerHTML
});

const canvas = document.createElement('canvas');
// const canvas = document.querySelector('.canvas');
const wrapper = document.querySelector('.wrapper');


let _patchesCount = 0;
let _currentPatchesCount = 0;
class Patch  {
    constructor(x, y, width, height, ctx) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.el = null;
        this.ctx = ctx;
        _patchesCount++;
    }
    static get patchesCount() {
        return _patchesCount;
    }
    static set currentCount(val) {
        _currentPatchesCount = val;
    }
    static get currentCount() {
        return _currentPatchesCount;
    }
    getImageScore() {
        const imageData = this.ctx.getImageData(this.x, this.y, this.width, this.height);
        let imageScore = 0;

        for (let i = 0; i < imageData.data.length; i += 4) {
            let r = imageData.data[i] / 3;
            let g = imageData.data[i + 1] / 3;
            let b = imageData.data[i + 2] / 3;
            let pixelScore = r + g + b;
            
            if (pixelScore >= 100) {
                imageScore++;
            }
        }
        return imageScore;
    }
    createElement() {
        this.el = document.createElement('div');
        this.el.classList.add('motion');
        this.el.style.left = `${this.x}px`;
        this.el.style.width = `${this.width-2}px`;
        this.el.style.height = `${this.height-2}px`;
        this.el.style.top = `${this.y}px`;
        this.el.addEventListener('motionEvent',(e)=>this.watch(e))
        wrapper.appendChild(this.el);
        this.animation = new Animation(new KeyframeEffect(
            this.el, [
                { border: '1px solid yellow' }, { border: '0px' }
            ], { duration: 4000, easing: 'ease-in-out' }), document.timeline);
    }
    watch(e) {
        setTimeout(() => {
            this.motionDetected();
        }, 0);
    }
    motionDetected() {
        if (this.getImageScore() > 50) {
            this.animation.finish();
            this.animation.play();
        }
        Patch.currentCount = Patch.currentCount + 1;
        if (Patch.currentCount === Patch.patchesCount) {
            document.querySelector('.video').dispatchEvent(imageProcessedEvent)
            Patch.currentCount = 0;
        }
    }
}


const patches = [];
    
canvas.width = 800;
canvas.height = 600;
const [w,h] = [40,30]
const ctx = canvas.getContext('2d');

for (let x = 0; x < canvas.width; x+=w){
    for (let y = 0; y < canvas.height; y+=h){
        const patch = new Patch(x, y, w, h, ctx);
        patch.createElement();
        patches.push(patch);
    }
}
const event = new CustomEvent('motionEvent');
const imageProcessedEvent = new CustomEvent('imageProcessed');
// event.initEvent('motion', true, true);

document.querySelector('.video').addEventListener('canplay', function() {
    
    this.addEventListener('imageProcessed', () => {
        processImage(video);
    })
    processImage(video);
});

function processImage(video) {
    setTimeout(() => {
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        setTimeout(() => {
            ctx.globalCompositeOperation = 'difference';
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            patches.map(patch => patch.el.dispatchEvent(event));
        }, 20);
    }, 20);
}

</script>

</html>
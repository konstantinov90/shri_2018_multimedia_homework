<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono|VT323" rel="stylesheet"> 
    <link href="css/build/style.css" rel="stylesheet"> 
    <title>Multimedia homework</title>
</head>
<body>
    <div class="wrapper">
        <video class="video" loop="loop" width="400px"
            src="img/aBx3pbP_460sv.mp4" autoplay controls
        ></video>
        <canvas class="video-overlay"></canvas>
            <!--poster="https://source.unsplash.com/random/600x400"-->
        <div class="interface">
            <p class="interface-answer glitch">Hello everyone</p>
            <div class="interface-aux">
                <p data-text="Lorem ipsum dolor, sit amet consectetur adipisicing elit. Vitae dignissimos, doloremque laborum, quod ullam autem quas praesentium quisquam, at voluptatibus est harum sit dolorem "></p>
            </div>
        </div>
        <div class="motion-frame"></div>
        <canvas class="canvas"></canvas>
    </div>
</body>
<script src="https://s3-us-west-2.amazonaws.com/s.cdpn.io/641/web-animations-next.min.js"></script>
<script>

const interfaceAuxP = document.querySelector('.interface-aux').querySelector('p');
const letters = interfaceAuxP.dataset.text.split('');
function insertLetter(child) {
    const letter = letters.shift();
    if (!letter) return;
    if (letter === ' ' || !child) {
        child = document.createElement('span');
        child.classList.add('glitch-2')
        interfaceAuxP.appendChild(child);
    }
    child.innerHTML += letter;
    requestAnimationFrame(()=>insertLetter(child));
}
requestAnimationFrame(insertLetter);

window.AudioContext = window.AudioContext || window.webkitAudioContext;
const audioContext = new AudioContext();

const constraints = {
    video: true,
    audio: true
};

const video = document.querySelector('.video');

function drawBuffer( width, height, context, data ) {
    var step = Math.ceil( data.length / width );
    var amp = height / 2;
    context.fillStyle = "silver";
    context.clearRect(0,0,width,height);
    for(var i=0; i < width; i++){
        var min = 1.0;
        var max = -1.0;
        for (j=0; j<step; j++) {
            var datum = data[(i*step)+j]; 
            if (datum < min)
                min = datum;
            if (datum > max)
                max = datum;
        }
        context.fillRect(i,(1+min)*amp,1,Math.max(1,(max-min)*amp));
    }
}


function handleSuccess(stream) {
    console.log(stream)
    video.srcObject = stream;
    const audioInput = audioContext.createMediaStreamSource(stream);
    const inputNode = audioContext.createGain();
    inputNode.gain.value = 2;
    audioInput.connect(inputNode);
    const analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    inputNode.connect(analyser);
    // analyser.connect(audioContext.destination);
    const dataArray = new Uint8Array(analyser.fftSize); // Uint8Array should be the same length as the fftSize 
    // drawBuffer(200, 100, document.querySelector('.canvas').getContext('2d'), dataArray);
    const myCanvas = document.querySelector('.canvas').getContext('2d')
    WIDTH = 800;
    HEIGHT = 150;
    bufferLength = 2048;
    myCanvas.clearRect(0, 0, WIDTH, HEIGHT);

    function draw() {
        drawVisual = requestAnimationFrame(draw);
        analyser.getByteTimeDomainData(dataArray);
        
        myCanvas.fillRect(0, 0, WIDTH, HEIGHT);
        myCanvas.lineWidth = 4;
        myCanvas.strokeStyle = 'lightgreen';

        myCanvas.beginPath();
        var sliceWidth = WIDTH * 1.0 / bufferLength;
        var x = 0;
        
        for(var i = 0; i < bufferLength; i++) {
    
            var v = dataArray[i] / 128.0;
            var y = (v-1)*30 + HEIGHT/2;

            if(i === 0) {
            myCanvas.moveTo(x, y);
            } else {
            myCanvas.lineTo(x, y);
            }

            x += sliceWidth;
        };
    
        myCanvas.lineTo(canvas.width, canvas.height/2);
        myCanvas.stroke();
        };

    draw();

}

function handleError(error) {
  console.error('Reeeejected!', error);
}

navigator.mediaDevices.getUserMedia(constraints).
  then(handleSuccess).catch(handleError);

function comparePixel(p1, p2) {
	var matches = true;
	var sensitivity = 40;
 
	for(var i = 0; i < p1.length; i++) {
		var t1 = Math.round(p1[i]/10)*10;
		var t2 = Math.round(p2[i]/10)*10;
 
		if(t1 != t2) {
			if((t1+sensitivity < t2 || t1-sensitivity > t2)) {
				matches = false;
			}
		}
	}
 
	return matches;
}

function saturateGreen(imageData) {
    for (var i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] = 0;
        imageData.data[i + 1] = Math.min(imageData.data[i + 1]*4, 255);
        imageData.data[i + 2] = 0;
        imageData.data[i + 3] = imageData.data[i + 1] > 50? 255: 0;
    }
    return imageData;
}

document.addEventListener('DOMContentLoaded', function() {
    const glitch = this.querySelector('.glitch');
    glitch.dataset.text = glitch.innerHTML
});

const canvas = document.createElement('canvas');
// document.querySelector('.wrapper').appendChild(canvas)
// const canvas = document.querySelector('.canvas');


    function getImageScore(imageData) {
        let imageScore = 0;

        for (let i = 0; i < imageData.data.length; i += 4) {
            const r = imageData.data[i] / 3;
            const g = imageData.data[i+1] / 3;
            const b = imageData.data[i + 2] / 3;
            const pixelScore = r + g + b;
            
            if (pixelScore > 20) {
                imageScore++;
            }
        }
        return imageScore;
    }

let _patchesCount = 0;
let _currentPatchesCount = 0;
class Patch  {
    constructor(x, y, width, height, ctx) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.el = null;
        this.ctx = ctx;
        _patchesCount++;
    }
    static get patchesCount() {
        return _patchesCount;
    }
    static set currentCount(val) {
        _currentPatchesCount = val;
    }
    static get currentCount() {
        return _currentPatchesCount;
    }
    getImageScore() {
        const imageData = saturateGreen(this.ctx.getImageData(this.x, this.y, this.width, this.height));
        let imageScore = 0;

        for (let i = 1; i < imageData.data.length; i += 4) {
            // const r = imageData.data[i] / 3;
            const g = imageData.data[i];
            // const b = imageData.data[i + 2] / 3;
            // const pixelScore = r + g + b;
            
            if (g >= 215) {
                imageScore++;
            }
        }
        return imageScore;
    }
    createElement(parent) {
        this.el = document.createElement('div');
        this.el.classList.add('motion-cell');
        this.el.style.left = `${this.x}px`;
        this.el.style.width = `${this.width-2}px`;
        this.el.style.height = `${this.height-2}px`;
        this.el.style.top = `${this.y}px`;
        this.el.addEventListener('motionEvent',(e)=>this.watch(e))
        parent.appendChild(this.el);
        this.animation = new Animation(new KeyframeEffect(
            this.el, [
                { border: '1px solid yellow' }, { border: '0px' }
            ], { duration: 2000 }), document.timeline);
    }
    watch(e) {
        setTimeout(() => {
            this.motionDetected();
        }, 0);
    }
    motionDetected() {
        if (this.getImageScore() > 50) {
            requestAnimationFrame(()=>{
                // this.animation.finish();
                // this.animation.play();
            });
        }
        Patch.currentCount = Patch.currentCount + 1;
        if (Patch.currentCount === Patch.patchesCount) {
            video.dispatchEvent(imageProcessedEvent)
            Patch.currentCount = 0;
        }
    }
}


const patches = [];
    
canvas.width = 800;
canvas.height = 600;
const [w,h] = [40,30]
const ctx = canvas.getContext('2d');
const motionFrame = document.querySelector('.motion-frame');

for (let x = 0; x < canvas.width; x+=w){
    for (let y = 0; y < canvas.height; y+=h){
        const patch = new Patch(x, y, w, h, ctx);
        patch.createElement(motionFrame);
        patches.push(patch);
    }
}
const event = new CustomEvent('motionEvent');
const imageProcessedEvent = new CustomEvent('imageProcessed');
// event.initEvent('motion', true, true);

const helperCanvas = document.createElement('canvas');
helperCanvas.width = canvas.width;
helperCanvas.height = canvas.height;
helperCanvas.style.background = 'darkred'
const helperCtx = helperCanvas.getContext('2d');

// video.addEventListener('canplaythrough', function() {
    
    video.addEventListener('imageProcessed', () => {
        processImage(video);
    })

setTimeout(()=>{
    // processImage(video);

},1100)
    // });
    

const overlay = document.querySelector('.video-overlay');
overlay.width = canvas.width;
overlay.height = canvas.height;
const overlayCtx = overlay.getContext('2d');
// overlayCtx.globalCompositeOperation = 'source-over';
// const body = document.querySelector('body').appendChild(helperCanvas);

function processImage(video) {
    // console.log(new Date())
    setTimeout(() => {
        ctx.globalCompositeOperation = 'source-over';
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        setTimeout(() => {
            ctx.globalCompositeOperation = 'difference';
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            imgData = saturateGreen(ctx.getImageData(0, 0, canvas.width, canvas.height));
            // if (getImageScore(imgData) > 10) {
                oldImgData = overlayCtx.getImageData(0, 0, canvas.width, canvas.height);
                overlayCtx.putImageData(sumImageDatas(multiplyImageData(oldImgData, 0.94), imgData), 0, 0)
                // helperCtx.globalCompositeOperation = 'copy';
                helperCtx.putImageData(sumImageDatas(multiplyImageData(oldImgData, 0.85), imgData), 0, 0)
                // setTime
                // console.log(getImageScore(imgData))
            // }
            // ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            // patches.map(patch => patch.el.dispatchEvent(event));
            video.dispatchEvent(imageProcessedEvent)
        },20);
    },20);
}

function multiplyImageData(imageData, multiplier) {
    for (let i = 0; i < imageData.data.length; i++) {
        imageData.data[i] *= multiplier
    }
    return imageData;
}
function sumImageDatas(imageData1, imageData2) {
    if (imageData1.data.length !== imageData2.data.length) {
        throw new Error('imageDatas sizes uneven');
        alert('Ты что-то делаешь не так');
    }
    for (let i = 0; i < imageData1.data.length; i++) {
        imageData1.data[i] = Math.min(imageData1.data[i] + imageData2.data[i], 255);
    }
    return imageData1;
}

</script>

</html>